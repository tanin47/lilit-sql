# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `sexp_processor` gem.
# Please instead update this file by running `bin/tapioca gem sexp_processor`.

# A simple subclass of SexpProcessor that tracks method and class
# stacks for you. Use #method_name, #klass_name, or #signature to
# refer to where you're at in processing. If you have to subclass
# process_(class|module|defn|defs) you _must_ call super.
#
# source://sexp_processor//lib/sexp_processor.rb#482
class MethodBasedSexpProcessor < ::SexpProcessor
  # @return [MethodBasedSexpProcessor] a new instance of MethodBasedSexpProcessor
  #
  # source://sexp_processor//lib/sexp_processor.rb#509
  def initialize; end

  # A stack of the classes/modules that are being processed
  #
  # source://sexp_processor//lib/sexp_processor.rb#489
  def class_stack; end

  # Adds name to the class stack, for the duration of the block
  #
  # source://sexp_processor//lib/sexp_processor.rb#521
  def in_klass(name); end

  # Adds name to the method stack, for the duration of the block
  #
  # source://sexp_processor//lib/sexp_processor.rb#548
  def in_method(name, file, line, line_max = T.unsafe(nil)); end

  # Tracks whether we're in a singleton class or not. Doesn't track
  # actual receiver.
  #
  # source://sexp_processor//lib/sexp_processor.rb#562
  def in_sklass; end

  # Returns the first class in the list, or @@no_class if there are
  # none.
  #
  # source://sexp_processor//lib/sexp_processor.rb#576
  def klass_name; end

  # A lookup table of all the method locations that have been
  # processed so far.
  #
  # source://sexp_processor//lib/sexp_processor.rb#507
  def method_locations; end

  # Returns the first method in the list, or "#none" if there are
  # none.
  #
  # source://sexp_processor//lib/sexp_processor.rb#592
  def method_name; end

  # A stack of the methods that are being processed. You'd think it'd
  # only ever be 1 deep, but you'd be wrong. People do terrible things
  # in/to ruby.
  #
  # source://sexp_processor//lib/sexp_processor.rb#496
  def method_stack; end

  # Process a class node until empty. Tracks all nesting. If you have
  # to subclass and override this method, you can call super with a
  # block.
  #
  # source://sexp_processor//lib/sexp_processor.rb#603
  def process_class(exp); end

  # Process a method node until empty. Tracks your location. If you
  # have to subclass and override this method, you can clall super
  # with a block.
  #
  # source://sexp_processor//lib/sexp_processor.rb#620
  def process_defn(exp); end

  # Process a singleton method node until empty. Tracks your location.
  # If you have to subclass and override this method, you can clall
  # super with a block.
  #
  # source://sexp_processor//lib/sexp_processor.rb#639
  def process_defs(exp); end

  # Process a module node until empty. Tracks all nesting. If you have
  # to subclass and override this method, you can clall super with a
  # block.
  #
  # source://sexp_processor//lib/sexp_processor.rb#657
  def process_module(exp); end

  # Process a singleton class node until empty. Tracks all nesting. If
  # you have to subclass and override this method, you can clall super
  # with a block.
  #
  # source://sexp_processor//lib/sexp_processor.rb#674
  def process_sclass(exp); end

  # Process each element of #exp in turn.
  #
  # source://sexp_processor//lib/sexp_processor.rb#689
  def process_until_empty(exp); end

  # A stack of the singleton classes that are being processed.
  #
  # source://sexp_processor//lib/sexp_processor.rb#501
  def sclass; end

  # Returns the method signature for the current method.
  #
  # source://sexp_processor//lib/sexp_processor.rb#699
  def signature; end

  # Reset the method stack for the duration of the block. Used for
  # class scoping.
  #
  # source://sexp_processor//lib/sexp_processor.rb#707
  def with_new_method_stack; end
end

# Raised by SexpProcessor if a processor did not process every node in
# a sexp and @require_empty is true.
#
# source://sexp_processor//lib/sexp_processor.rb#749
class NotEmptyError < ::SexpProcessorError; end

# source://sexp_processor//lib/sexp_processor.rb#716
class Object < ::BasicObject
  include ::Kernel
  include ::PP::ObjectMixin

  # deep_clone is the usual Marshalling hack to make a deep copy.
  # It is rather slow, so use it sparingly. Helps with debugging
  # SexpProcessors since you usually shift off sexps.
  #
  # source://sexp_processor//lib/sexp_processor.rb#723
  def deep_clone; end

  private

  # source://sexp_processor//lib/sexp.rb#391
  def s(*args, &blk); end
end

# source://sexp_processor//lib/sexp.rb#11
class Sexp < ::Array
  # Create a new Sexp containing +args+.
  #
  # @return [Sexp] a new instance of Sexp
  #
  # source://sexp_processor//lib/sexp.rb#35
  def initialize(*args); end

  # Verifies that +pattern+ is a Matcher and then dispatches to its #/
  # method.
  #
  # TODO: rename grep? match_all ? find_all ?
  #
  # @raise [ArgumentError]
  #
  # source://sexp_processor//lib/sexp_matcher.rb#30
  def /(pattern); end

  # source://sexp_processor//lib/sexp.rb#76
  def ==(obj); end

  # Verifies that +pattern+ is a Matcher and then dispatches to its
  # #=~ method.
  #
  # See Matcher.=~
  #
  # @raise [ArgumentError]
  #
  # source://sexp_processor//lib/sexp_matcher.rb#8
  def =~(pattern); end

  def _concat(*_arg0); end

  # Returns true if the node_type is +array+ or +args+.
  #
  # REFACTOR: to TypedSexp - we only care when we have units.
  #
  # @return [Boolean]
  #
  # source://sexp_processor//lib/sexp.rb#93
  def array_type?; end

  # source://ruby_parser/3.20.2/lib/rp_extensions.rb#47
  def block_pass?; end

  # source://ruby_parser/3.20.2/lib/ruby_parser_extras.rb#12
  def check_line_numbers; end

  # Optional comments above/aside this sexp. Usually set by ruby_parser.
  #
  # source://sexp_processor//lib/sexp.rb#28
  def comments; end

  # Optional comments above/aside this sexp. Usually set by ruby_parser.
  #
  # source://sexp_processor//lib/sexp.rb#28
  def comments=(_arg0); end

  # source://sexp_processor//lib/sexp.rb#99
  def compact; end

  # Recursively enumerates the sexp yielding to +block+ for every sub-Sexp.
  #
  # Returning :skip will stop traversing that subtree:
  #
  #   sexp.deep_each do |s|
  #     next :skip if s.sexp_type == :if
  #     # ...
  #   end
  #
  # source://sexp_processor//lib/sexp.rb#113
  def deep_each(&block); end

  # Return the maximum depth of the sexp. One-based.
  #
  # source://sexp_processor//lib/sexp.rb#125
  def depth; end

  # Enumeratates the sexp yielding to +b+ when the node_type == +t+.
  #
  # source://sexp_processor//lib/sexp.rb#132
  def each_of_type(t, &b); end

  # Enumerates all sub-sexps skipping non-Sexp elements.
  #
  # source://sexp_processor//lib/sexp.rb#144
  def each_sexp; end

  # @return [Boolean]
  #
  # source://sexp_processor//lib/sexp.rb#80
  def eql?(o); end

  # Accessors for the file. Usually set by ruby_parser.
  #
  # source://sexp_processor//lib/sexp.rb#23
  def file; end

  # Accessors for the file. Usually set by ruby_parser.
  #
  # source://sexp_processor//lib/sexp.rb#23
  def file=(_arg0); end

  # Replaces all elements whose node_type is +from+ with +to+. Used
  # only for the most trivial of rewrites.
  #
  # source://sexp_processor//lib/sexp.rb#158
  def find_and_replace_all(from, to); end

  # source://sexp_processor//lib/sexp.rb#199
  def find_node(name, delete = T.unsafe(nil)); end

  # Find every node with type +name+.
  #
  # source://sexp_processor//lib/sexp.rb#217
  def find_nodes(name); end

  # Replaces all Sexps matching +pattern+ with Sexp +repl+.
  #
  # source://sexp_processor//lib/sexp.rb#171
  def gsub(pattern, repl); end

  # source://sexp_processor//lib/sexp.rb#84
  def hash; end

  # Returns the node type of the Sexp.
  #
  # source://sexp_processor//lib/sexp.rb#284
  def head; end

  # source://sexp_processor//lib/sexp.rb#190
  def inspect; end

  # If passed a line number, sets the line and returns self. Otherwise
  # returns the line number. This allows you to do message cascades
  # and still get the sexp back.
  #
  # source://sexp_processor//lib/sexp.rb#228
  def line(n = T.unsafe(nil)); end

  # A setter for the line this sexp was found on. Usually set by ruby_parser.
  #
  # source://sexp_processor//lib/sexp.rb#13
  def line=(_arg0); end

  # Returns the maximum line number of the children of self.
  #
  # source://sexp_processor//lib/sexp.rb#241
  def line_max; end

  # Set the maximum line number for this sexp. Often set by ruby_parser.
  #
  # source://sexp_processor//lib/sexp.rb#18
  def line_max=(_arg0); end

  # source://ruby_parser/3.20.2/lib/ruby_parser_extras.rb#23
  def line_min; end

  # source://sexp_processor//lib/sexp.rb#72
  def map(&blk); end

  # Returns the size of the sexp, flattened.
  #
  # source://sexp_processor//lib/sexp.rb#248
  def mass; end

  # Returns the node named +node+, deleting it if +delete+ is true.
  #
  # source://sexp_processor//lib/sexp.rb#255
  def method_missing(meth, delete = T.unsafe(nil)); end

  # Creates a new sexp with the new contents of +body+, but with the
  # same +file+, +line+, and +comment+ as self.
  #
  # source://sexp_processor//lib/sexp.rb#63
  def new(*body); end

  # source://ruby_parser/3.20.2/lib/ruby_parser_extras.rb#27
  def nil_line?; end

  # source://ruby_parser/3.20.2/lib/rp_extensions.rb#43
  def paren; end

  # source://ruby_parser/3.20.2/lib/rp_extensions.rb#41
  def paren=(_arg0); end

  # source://sexp_processor//lib/sexp.rb#272
  def pretty_print(q); end

  # Recursively searches for the +pattern+ yielding each match, and
  # replacing it with the result of the block.
  #
  # @raise [ArgumentError]
  #
  # source://sexp_processor//lib/sexp_matcher.rb#57
  def replace_sexp(pattern, &block); end

  # @return [Boolean]
  #
  # source://sexp_processor//lib/sexp.rb#267
  def respond_to?(msg, private = T.unsafe(nil)); end

  # Returns the Sexp body (starting at +from+, defaulting to 1), ie
  # the values without the node type.
  #
  # source://sexp_processor//lib/sexp.rb#299
  def rest(from = T.unsafe(nil)); end

  # Verifies that +pattern+ is a Matcher and then dispatches to its
  # #satisfy? method.
  #
  # TODO: rename match?
  #
  # @raise [ArgumentError]
  # @return [Boolean]
  #
  # source://sexp_processor//lib/sexp_matcher.rb#19
  def satisfy?(pattern); end

  # Recursively searches for the +pattern+ yielding the matches.
  #
  # @raise [ArgumentError]
  #
  # source://sexp_processor//lib/sexp_matcher.rb#38
  def search_each(pattern, &block); end

  # Returns the Sexp body (starting at +from+, defaulting to 1), ie
  # the values without the node type.
  #
  # source://sexp_processor//lib/sexp.rb#299
  def sexp_body(from = T.unsafe(nil)); end

  # Sets the Sexp body to new content.
  #
  # source://sexp_processor//lib/sexp.rb#306
  def sexp_body=(v); end

  # Returns the node type of the Sexp.
  #
  # source://sexp_processor//lib/sexp.rb#284
  def sexp_type; end

  # Sets the node type of the Sexp.
  #
  # source://sexp_processor//lib/sexp.rb#291
  def sexp_type=(v); end

  # Returns the bare bones structure of the sexp.
  # s(:a, :b, s(:c, :d), :e) => s(:a, s(:c))
  #
  # source://sexp_processor//lib/sexp.rb#326
  def structure; end

  # Replaces the Sexp matching +pattern+ with +repl+.
  #
  # source://sexp_processor//lib/sexp.rb#338
  def sub(pattern, repl); end

  # source://sexp_processor//lib/sexp.rb#368
  def to_a; end

  # source://sexp_processor//lib/sexp.rb#190
  def to_s; end

  # Return the value (last item) of a single element sexp (eg `s(:lit, 42)`).
  #
  # source://sexp_processor//lib/sexp.rb#377
  def value; end

  class << self
    # Matches when sub-expression does not match.
    #
    # This is also available via Matcher#-@.
    #
    # See Not for examples.
    #
    # @return [Boolean]
    #
    # source://sexp_processor//lib/sexp_matcher.rb#155
    def -(arg); end

    # Matches any single item.
    #
    # See Wild for examples.
    #
    # source://sexp_processor//lib/sexp_matcher.rb#93
    def _; end

    # Matches all remaining input.
    #
    # See Remaining for examples.
    #
    # source://sexp_processor//lib/sexp_matcher.rb#104
    def ___; end

    # Matches only when all sub-expressions match.
    #
    # This is also available via Matcher#&.
    #
    # See All for examples.
    #
    # source://sexp_processor//lib/sexp_matcher.rb#144
    def all(*args); end

    # Matches when any of the sub-expressions match.
    #
    # This is also available via Matcher#|.
    #
    # See Any for examples.
    #
    # source://sexp_processor//lib/sexp_matcher.rb#133
    def any(*args); end

    # Matches any atom.
    #
    # See Atom for examples.
    #
    # source://sexp_processor//lib/sexp_matcher.rb#122
    def atom; end

    # Matches anything that has a child matching the sub-expression.
    #
    # See Child for examples.
    #
    # source://sexp_processor//lib/sexp_matcher.rb#170
    def child(child); end

    # Creates a new Sexp from Array +a+.
    #
    # source://sexp_processor//lib/sexp.rb#44
    def from_array(a); end

    # Matches an expression or any expression that includes the child.
    #
    # See Include for examples.
    #
    # source://sexp_processor//lib/sexp_matcher.rb#113
    def include(child); end

    # Matches an atom of the specified +klass+ (or module).
    #
    # See Pattern for examples.
    #
    # source://sexp_processor//lib/sexp_matcher.rb#208
    def k(klass); end

    # Matches any atom who's string representation matches the patterns
    # passed in.
    #
    # See Pattern for examples.
    #
    # source://sexp_processor//lib/sexp_matcher.rb#190
    def m(*values); end

    # Matches when sub-expression does not match.
    #
    # This is also available via Matcher#-@.
    #
    # See Not for examples.
    #
    # @return [Boolean]
    #
    # source://sexp_processor//lib/sexp_matcher.rb#155
    def not?(arg); end

    # Matches an S-Expression.
    #
    # See Matcher for examples.
    #
    # source://sexp_processor//lib/sexp_matcher.rb#78
    def q(*args); end

    # source://sexp_processor//lib/sexp_matcher.rb#82
    def s(*args); end

    # Matches anything having the same sexp_type, which is the first
    # value in a Sexp.
    #
    # See Type for examples.
    #
    # source://sexp_processor//lib/sexp_matcher.rb#180
    def t(name); end
  end
end

# Matches only when all sub-expressions match.
#
# This is also available via Matcher#&.
#
# examples:
#
#   s(:a)     / s{ all(s(:a), s(:b)) }    #=> []
#   s(:a, :b) / s{ t(:a) & include(:b)) } #=> [s(:a, :b)]
#
# source://sexp_processor//lib/sexp_matcher.rb#647
class Sexp::All < ::Sexp::Matcher
  # Create an All matcher which will match all of the +options+.
  #
  # @return [All] a new instance of All
  #
  # source://sexp_processor//lib/sexp_matcher.rb#656
  def initialize(*options); end

  # source://sexp_processor//lib/sexp_matcher.rb#669
  def ==(o); end

  # source://sexp_processor//lib/sexp_matcher.rb#673
  def inspect; end

  # The collection of sub-matchers to match against.
  #
  # source://sexp_processor//lib/sexp_matcher.rb#651
  def options; end

  # source://sexp_processor//lib/sexp_matcher.rb#677
  def pretty_print(q); end

  # Satisfied when all sub expressions match +o+
  #
  # @return [Boolean]
  #
  # source://sexp_processor//lib/sexp_matcher.rb#663
  def satisfy?(o); end
end

# Matches when any of the sub-expressions match.
#
# This is also available via Matcher#|.
#
# examples:
#
#   s(:a) / s{ any(s(:a), s(:b)) } #=> [s(:a)]
#   s(:a) / s{     s(:a) | s(:b) } #=> [s(:a)] # same thing via |
#   s(:a) / s{ any(s(:b), s(:c)) } #=> []
#
# source://sexp_processor//lib/sexp_matcher.rb#598
class Sexp::Any < ::Sexp::Matcher
  # Create an Any matcher which will match any of the +options+.
  #
  # @return [Any] a new instance of Any
  #
  # source://sexp_processor//lib/sexp_matcher.rb#607
  def initialize(*options); end

  # source://sexp_processor//lib/sexp_matcher.rb#620
  def ==(o); end

  # source://sexp_processor//lib/sexp_matcher.rb#624
  def inspect; end

  # The collection of sub-matchers to match against.
  #
  # source://sexp_processor//lib/sexp_matcher.rb#602
  def options; end

  # source://sexp_processor//lib/sexp_matcher.rb#628
  def pretty_print(q); end

  # Satisfied when any sub expressions match +o+
  #
  # @return [Boolean]
  #
  # source://sexp_processor//lib/sexp_matcher.rb#614
  def satisfy?(o); end
end

# Matches any atom (non-Sexp).
#
# examples:
#
#   s(:a)        / s{ s(atom) } #=> [s(:a)]
#   s(:a, s(:b)) / s{ s(atom) } #=> [s(:b)]
#
# source://sexp_processor//lib/sexp_matcher.rb#790
class Sexp::Atom < ::Sexp::Matcher
  # source://sexp_processor//lib/sexp_matcher.rb#798
  def inspect; end

  # source://sexp_processor//lib/sexp_matcher.rb#802
  def pretty_print(q); end

  # Satisfied when +o+ is an atom.
  #
  # @return [Boolean]
  #
  # source://sexp_processor//lib/sexp_matcher.rb#794
  def satisfy?(o); end
end

# Matches anything that has a child matching the sub-expression
#
# example:
#
#   s(s(s(s(s(:a))))) / s{ child(s(:a)) } #=> [s(s(s(s(s(:a))))),
#                                              s(s(s(s(:a)))),
#                                              s(s(s(:a))),
#                                              s(s(:a)),
#                                              s(:a)]
#
# source://sexp_processor//lib/sexp_matcher.rb#744
class Sexp::Child < ::Sexp::Matcher
  # Create a Child matcher which will match anything having a
  # descendant matching +child+.
  #
  # @return [Child] a new instance of Child
  #
  # source://sexp_processor//lib/sexp_matcher.rb#754
  def initialize(child); end

  # source://sexp_processor//lib/sexp_matcher.rb#767
  def ==(o); end

  # The child to match.
  #
  # source://sexp_processor//lib/sexp_matcher.rb#748
  def child; end

  # source://sexp_processor//lib/sexp_matcher.rb#771
  def inspect; end

  # source://sexp_processor//lib/sexp_matcher.rb#775
  def pretty_print(q); end

  # Satisfied if matches +child+ or +o+ has a descendant matching
  # +child+.
  #
  # @return [Boolean]
  #
  # source://sexp_processor//lib/sexp_matcher.rb#762
  def satisfy?(o); end
end

# Matches an expression or any expression that includes the child.
#
# examples:
#
#   s(:a, :b)   / s{ include(:b) } #=> [s(:a, :b)]
#   s(s(s(:a))) / s{ include(:a) } #=> [s(:a)]
#
# source://sexp_processor//lib/sexp_matcher.rb#938
class Sexp::Include < ::Sexp::Matcher
  # Creates a Matcher which will match any Sexp that contains the
  # +value+.
  #
  # @return [Include] a new instance of Include
  #
  # source://sexp_processor//lib/sexp_matcher.rb#948
  def initialize(value); end

  # source://sexp_processor//lib/sexp_matcher.rb#963
  def ==(o); end

  # source://sexp_processor//lib/sexp_matcher.rb#967
  def inspect; end

  # source://sexp_processor//lib/sexp_matcher.rb#971
  def pretty_print(q); end

  # Satisfied if a +o+ is a Sexp and one of +o+'s elements matches
  # value
  #
  # @return [Boolean]
  #
  # source://sexp_processor//lib/sexp_matcher.rb#956
  def satisfy?(o); end

  # The value that should be included in the match.
  #
  # source://sexp_processor//lib/sexp_matcher.rb#942
  def value; end
end

# Matches any atom that is an instance of the specified class or module.
#
# examples:
#
#   s(:lit, 6.28) / s{ q(:lit, k(Float)) }                   #=> [s(:lit, 6.28)]
#
# source://sexp_processor//lib/sexp_matcher.rb#871
class Sexp::Klass < ::Sexp::Pattern
  # source://sexp_processor//lib/sexp_matcher.rb#876
  def inspect; end

  # source://sexp_processor//lib/sexp_matcher.rb#880
  def pretty_print(q); end

  # @return [Boolean]
  #
  # source://sexp_processor//lib/sexp_matcher.rb#872
  def satisfy?(o); end
end

# Wraps the results of a Sexp query. MatchCollection defines
# MatchCollection#/ so that you can chain queries.
#
# For instance:
#   res = s(:a, s(:b)) / s{ s(:a,_) } / s{ s(:b) }
#
# source://sexp_processor//lib/sexp_matcher.rb#1078
class Sexp::MatchCollection < ::Array
  # See Traverse#search
  #
  # source://sexp_processor//lib/sexp_matcher.rb#1082
  def /(pattern); end

  # source://sexp_processor//lib/sexp_matcher.rb#1088
  def inspect; end

  # source://sexp_processor//lib/sexp_matcher.rb#1094
  def pretty_print(q); end

  # source://sexp_processor//lib/sexp_matcher.rb#1088
  def to_s; end
end

# Defines a family of objects that can be used to match sexps to
# certain types of patterns, much like regexps can be used on
# strings. Generally you won't use this class directly.
#
# You would normally create a matcher using the top-level #s method,
# but with a block, calling into the Sexp factory methods. For example:
#
#   s{ s(:class, m(/^Test/), _, ___) }
#
# This creates a matcher for classes whose names start with "Test".
# It uses Sexp.m to create a Sexp::Matcher::Pattern matcher, Sexp._
# to create a Sexp::Matcher::Wild matcher, and Sexp.___ to create a
# Sexp::Matcher::Remaining matcher. It works like this:
#
#   s{              # start to create a pattern
#     s(            # create a sexp matcher
#       :class.     # for class nodes
#       m(/^Test/), # matching name slots that start with "Test"
#       _,          # any superclass value
#       ___         # and whatever is in the class
#      )
#    }
#
# Then you can use that with #=~, #/, Sexp#replace_sexp, and others.
#
# For more examples, see the various Sexp class methods, the examples,
# and the tests supplied with Sexp.
#
# * For pattern creation, see factory methods: Sexp::_, Sexp::___, etc.
# * For matching returning truthy/falsey results, see Sexp#=~.
# * For case expressions, see Matcher#===.
# * For getting all subtree matches, see Sexp#/.
#
# If rdoc didn't suck, these would all be links.
#
# source://sexp_processor//lib/sexp_matcher.rb#248
class Sexp::Matcher < ::Sexp
  # Combines the Matcher with another Matcher, the resulting one will
  # be satisfied only if both Matchers would be satisfied.
  #
  # TODO: redirect
  # Example:
  #   t(:a) & include(:b)
  #
  # source://sexp_processor//lib/sexp_matcher.rb#341
  def &(other); end

  # Returns a Matcher that matches whenever this Matcher would not have matched
  #
  # Example:
  #   -s(:a)
  #
  # source://sexp_processor//lib/sexp_matcher.rb#351
  def -@; end

  # Searches through +sexp+ for all sub-trees that match this
  # matcher and returns a MatchCollection for each match.
  #
  # TODO: redirect?
  # Example:
  #   Q{ s(:b) } / s(:a, s(:b)) => [s(:b)]
  #
  # @raise [ArgumentError]
  #
  # source://sexp_processor//lib/sexp_matcher.rb#314
  def /(sexp); end

  # Tree equivalent to String#=~, returns true if +self+ matches
  # +sexp+ as a whole or in a sub-tree (if +match_subs?+).
  #
  # TODO: maybe this should NOT be aliased to === ?
  #
  # TODO: example
  # TODO?: alias === satisfy?
  #
  # @raise [ArgumentError]
  #
  # source://sexp_processor//lib/sexp_matcher.rb#297
  def ===(sexp); end

  # Tree equivalent to String#=~, returns true if +self+ matches
  # +sexp+ as a whole or in a sub-tree (if +match_subs?+).
  #
  # TODO: maybe this should NOT be aliased to === ?
  #
  # TODO: example
  #
  # @raise [ArgumentError]
  #
  # source://sexp_processor//lib/sexp_matcher.rb#297
  def =~(sexp); end

  # Returns a Matcher that matches if this has a sibling +o+
  #
  # Example:
  #   s(:a) >> s(:b)
  #
  # source://sexp_processor//lib/sexp_matcher.rb#361
  def >>(other); end

  # Is this matcher greedy? Defaults to false.
  #
  # @return [Boolean]
  #
  # source://sexp_processor//lib/sexp_matcher.rb#368
  def greedy?; end

  # source://sexp_processor//lib/sexp_matcher.rb#372
  def inspect; end

  # source://sexp_processor//lib/sexp_matcher.rb#378
  def pretty_print(q); end

  # Does this matcher actually match +o+? Returns falsey if +o+ is
  # not a Sexp or if any sub-tree of +o+ is not satisfied by or
  # equal to its corresponding sub-matcher.
  #
  # --
  # TODO: push this up to Sexp and make this the workhorse
  # TODO: do the same with ===/satisfy?
  #
  # @return [Boolean]
  #
  # source://sexp_processor//lib/sexp_matcher.rb#274
  def satisfy?(o); end

  # Combines the Matcher with another Matcher, the resulting one will
  # be satisfied if either Matcher would be satisfied.
  #
  # TODO: redirect
  # Example:
  #   s(:a) | s(:b)
  #
  # source://sexp_processor//lib/sexp_matcher.rb#329
  def |(other); end

  class << self
    # Setter for +match_subs?+.
    #
    # source://sexp_processor//lib/sexp_matcher.rb#259
    def match_subs=(o); end

    # Should #=~ match sub-trees?
    #
    # @return [Boolean]
    #
    # source://sexp_processor//lib/sexp_matcher.rb#252
    def match_subs?; end

    # Parse a lispy string representation of a matcher into a Matcher.
    # See +Parser+.
    #
    # source://sexp_processor//lib/sexp_matcher.rb#390
    def parse(s); end
  end
end

# Converts from a lispy string to Sexp matchers in a safe manner.
#
#   "(a 42 _ (c) [t x] ___)" => s{ s(:a, 42, _, s(:c), t(:x), ___) }
#
# source://sexp_processor//lib/sexp_matcher.rb#399
class Sexp::Matcher::Parser
  # Create a new Parser instance on +s+
  #
  # @return [Parser] a new instance of Parser
  #
  # source://sexp_processor//lib/sexp_matcher.rb#409
  def initialize(s); end

  # Converts +s+ into a stream of tokens and adds them to +tokens+.
  #
  # source://sexp_processor//lib/sexp_matcher.rb#416
  def lex(s); end

  # Returns the next token and removes it from the stream or raises if empty.
  #
  # @raise [SyntaxError]
  #
  # source://sexp_processor//lib/sexp_matcher.rb#423
  def next_token; end

  # Parses tokens and returns a +Matcher+ instance.
  #
  # source://sexp_processor//lib/sexp_matcher.rb#438
  def parse; end

  # Parses a balanced command. A command is denoted by square
  # brackets and must conform to a whitelisted set of allowed
  # commands (see +ALLOWED+).
  #
  # @raise [SyntaxError]
  #
  # source://sexp_processor//lib/sexp_matcher.rb#515
  def parse_cmd; end

  # Parses a balanced list of expressions and returns the
  # equivalent matcher.
  #
  # source://sexp_processor//lib/sexp_matcher.rb#496
  def parse_list; end

  # Parses a string into a sexp matcher:
  #
  #   SEXP : "(" SEXP:args* ")"          => Sexp.q(*args)
  #        | "[" CMD:cmd sexp:args* "]"  => Sexp.cmd(*args)
  #        | "nil"                       => nil
  #        | /\d+/:n                     => n.to_i
  #        | "___"                       => Sexp.___
  #        | "_"                         => Sexp._
  #        | /^\/(.*)\/$/:re             => Regexp.new re[0]
  #        | /^"(.*)"$/:s                => String.new s[0]
  #        | UP_NAME:name                => Object.const_get name
  #        | NAME:name                   => name.to_sym
  # UP_NAME: /[A-Z]\w*/
  #   NAME : /:?[\w?!=~-]+/
  #    CMD : t | k | m | atom | not? | - | any | child | include
  #
  # source://sexp_processor//lib/sexp_matcher.rb#460
  def parse_sexp; end

  # Returns the next token without removing it from the stream.
  #
  # source://sexp_processor//lib/sexp_matcher.rb#431
  def peek_token; end

  # The stream of tokens to parse. See #lex.
  #
  # source://sexp_processor//lib/sexp_matcher.rb#404
  def tokens; end

  # The stream of tokens to parse. See #lex.
  #
  # source://sexp_processor//lib/sexp_matcher.rb#404
  def tokens=(_arg0); end
end

# A collection of allowed commands to convert into matchers.
#
# source://sexp_processor//lib/sexp_matcher.rb#508
Sexp::Matcher::Parser::ALLOWED = T.let(T.unsafe(nil), Array)

# Matches when sub-expression does not match.
#
# This is also available via Matcher#-@.
#
# examples:
#
#   s(:a) / s{ not?(s(:b)) } #=> [s(:a)]
#   s(:a) / s{ -s(:b) }      #=> [s(:a)]
#   s(:a) / s{ s(not? :a) } #=> []
#
# source://sexp_processor//lib/sexp_matcher.rb#697
class Sexp::Not < ::Sexp::Matcher
  # Creates a Matcher which will match any Sexp that does not match the +value+
  #
  # @return [Not] a new instance of Not
  #
  # source://sexp_processor//lib/sexp_matcher.rb#707
  def initialize(value); end

  # source://sexp_processor//lib/sexp_matcher.rb#711
  def ==(o); end

  # source://sexp_processor//lib/sexp_matcher.rb#722
  def inspect; end

  # source://sexp_processor//lib/sexp_matcher.rb#726
  def pretty_print(q); end

  # Satisfied if a +o+ does not match the +value+
  #
  # @return [Boolean]
  #
  # source://sexp_processor//lib/sexp_matcher.rb#718
  def satisfy?(o); end

  # The value to negate in the match.
  #
  # source://sexp_processor//lib/sexp_matcher.rb#702
  def value; end
end

# Matches any atom who's string representation matches the patterns
# passed in.
#
# examples:
#
#   s(:a) / s{ m('a') }                                      #=> [s(:a)]
#   s(:a) / s{ m(/\w/,/\d/) }                                #=> [s(:a)]
#   s(:tests, s(s(:test_a), s(:test_b))) / s{ m(/test_\w/) } #=> [s(:test_a),
#
# TODO: maybe don't require non-sexps? This does respond to =~ now.
#
# source://sexp_processor//lib/sexp_matcher.rb#819
class Sexp::Pattern < ::Sexp::Matcher
  # Create a Patten matcher which will match any atom that either
  # matches the input +pattern+.
  #
  # @return [Pattern] a new instance of Pattern
  #
  # source://sexp_processor//lib/sexp_matcher.rb#834
  def initialize(pattern); end

  # source://sexp_processor//lib/sexp_matcher.rb#826
  def ==(o); end

  # @return [Boolean]
  #
  # source://sexp_processor//lib/sexp_matcher.rb#855
  def eql?(o); end

  # source://sexp_processor//lib/sexp_matcher.rb#859
  def hash; end

  # source://sexp_processor//lib/sexp_matcher.rb#845
  def inspect; end

  # The regexp to match for the pattern.
  #
  # source://sexp_processor//lib/sexp_matcher.rb#824
  def pattern; end

  # source://sexp_processor//lib/sexp_matcher.rb#849
  def pretty_print(q); end

  # Satisfied if +o+ is an atom, and +o+ matches +pattern+
  #
  # @return [Boolean]
  #
  # source://sexp_processor//lib/sexp_matcher.rb#841
  def satisfy?(o); end
end

# Matches all remaining input. If remaining comes before any other
# matchers, they will be ignored.
#
# examples:
#
#   s(:a)         / s{ s(:a, ___ ) } #=> [s(:a)]
#   s(:a, :b, :c) / s{ s(:a, ___ ) } #=> [s(:a, :b, :c)]
#
# source://sexp_processor//lib/sexp_matcher.rb#566
class Sexp::Remaining < ::Sexp::Matcher
  # @return [Boolean]
  #
  # source://sexp_processor//lib/sexp_matcher.rb#574
  def greedy?; end

  # source://sexp_processor//lib/sexp_matcher.rb#578
  def inspect; end

  # source://sexp_processor//lib/sexp_matcher.rb#582
  def pretty_print(q); end

  # Always satisfied once this is reached. Think of it as a var arg.
  #
  # @return [Boolean]
  #
  # source://sexp_processor//lib/sexp_matcher.rb#570
  def satisfy?(o); end
end

# See Matcher for sibling relations: <,<<,>>,>
#
# source://sexp_processor//lib/sexp_matcher.rb#981
class Sexp::Sibling < ::Sexp::Matcher
  # Creates a Matcher which will match any pair of Sexps that are siblings.
  # Defaults to matching the immediate following sibling.
  #
  # @return [Sibling] a new instance of Sibling
  #
  # source://sexp_processor//lib/sexp_matcher.rb#1002
  def initialize(subject, sibling, distance = T.unsafe(nil)); end

  # source://sexp_processor//lib/sexp_matcher.rb#1027
  def ==(o); end

  # An optional distance requirement for the matcher.
  #
  # source://sexp_processor//lib/sexp_matcher.rb#996
  def distance; end

  # source://sexp_processor//lib/sexp_matcher.rb#1034
  def inspect; end

  # source://sexp_processor//lib/sexp_matcher.rb#1038
  def pretty_print(q); end

  # Satisfied if o contains +subject+ followed by +sibling+
  #
  # @return [Boolean]
  #
  # source://sexp_processor//lib/sexp_matcher.rb#1011
  def satisfy?(o); end

  # The RHS of the matcher.
  #
  # source://sexp_processor//lib/sexp_matcher.rb#991
  def sibling; end

  # The LHS of the matcher.
  #
  # source://sexp_processor//lib/sexp_matcher.rb#986
  def subject; end

  private

  # source://sexp_processor//lib/sexp_matcher.rb#1056
  def index_matches(pattern, o); end
end

# Matches anything having the same sexp_type, which is the first
# value in a Sexp.
#
# examples:
#
#   s(:a, :b) / s{ t(:a) }        #=> [s(:a, :b)]
#   s(:a, :b) / s{ t(:b) }        #=> []
#   s(:a, s(:b, :c)) / s{ t(:b) } #=> [s(:b, :c)]
#
# source://sexp_processor//lib/sexp_matcher.rb#897
class Sexp::Type < ::Sexp::Matcher
  # Creates a Matcher which will match any Sexp who's type is +type+, where a type is
  # the first element in the Sexp.
  #
  # @return [Type] a new instance of Type
  #
  # source://sexp_processor//lib/sexp_matcher.rb#904
  def initialize(type); end

  # source://sexp_processor//lib/sexp_matcher.rb#908
  def ==(o); end

  # source://sexp_processor//lib/sexp_matcher.rb#919
  def inspect; end

  # source://sexp_processor//lib/sexp_matcher.rb#923
  def pretty_print(q); end

  # Satisfied if the sexp_type of +o+ is +type+.
  #
  # @return [Boolean]
  #
  # source://sexp_processor//lib/sexp_matcher.rb#915
  def satisfy?(o); end

  # Returns the value of attribute sexp_type.
  #
  # source://sexp_processor//lib/sexp_matcher.rb#898
  def sexp_type; end
end

# source://sexp_processor//lib/sexp.rb#221
Sexp::UNASSIGNED = T.let(T.unsafe(nil), Object)

# Matches any single item.
#
# examples:
#
#   s(:a)           / s{ _ }    #=> [s(:a)]
#   s(:a, s(s(:b))) / s{ s(_) } #=> [s(s(:b))]
#
# source://sexp_processor//lib/sexp_matcher.rb#540
class Sexp::Wild < ::Sexp::Matcher
  # source://sexp_processor//lib/sexp_matcher.rb#548
  def inspect; end

  # source://sexp_processor//lib/sexp_matcher.rb#552
  def pretty_print(q); end

  # Matches any single element.
  #
  # @return [Boolean]
  #
  # source://sexp_processor//lib/sexp_matcher.rb#544
  def satisfy?(o); end
end

# A simple subclass of SexpProcessor that defines a pattern I commonly
# use: non-mutative and strict process that return assorted values;
# AKA, an interpreter.
#
# source://sexp_processor//lib/sexp_processor.rb#466
class SexpInterpreter < ::SexpProcessor
  # @return [SexpInterpreter] a new instance of SexpInterpreter
  #
  # source://sexp_processor//lib/sexp_processor.rb#467
  def initialize; end
end

# SexpProcessor provides a uniform interface to process Sexps.
#
# In order to create your own SexpProcessor subclass you'll need
# to call super in the initialize method, then set any of the
# Sexp flags you want to be different from the defaults.
#
# SexpProcessor uses a Sexp's type to determine which process method
# to call in the subclass.  For Sexp <code>s(:lit, 1)</code>
# SexpProcessor will call #process_lit, if it is defined.
#
# You can also specify a default method to call for any Sexp types
# without a process_<type> method or use the default processor provided to
# skip over them.
#
# Here is a simple example:
#
#   class MyProcessor < SexpProcessor
#     def initialize
#       super
#       self.strict = false
#     end
#
#     def process_lit(exp)
#       val = exp.shift
#       return val
#     end
#   end
#
# source://sexp_processor//lib/sexp_processor.rb#34
class SexpProcessor
  # Creates a new SexpProcessor.  Use super to invoke this
  # initializer from SexpProcessor subclasses, then use the
  # attributes above to customize the functionality of the
  # SexpProcessor
  #
  # @return [SexpProcessor] a new instance of SexpProcessor
  #
  # source://sexp_processor//lib/sexp_processor.rb#133
  def initialize; end

  # Raise if +exp+ is not empty.
  #
  # source://sexp_processor//lib/sexp_processor.rb#167
  def assert_empty(meth, exp, exp_orig); end

  # Raises unless the Sexp type for +list+ matches +typ+
  #
  # @raise [SexpTypeError]
  #
  # source://sexp_processor//lib/sexp_processor.rb#318
  def assert_type(list, typ); end

  # Automatically shifts off the Sexp type before handing the
  # Sexp to process_<type>
  #
  # source://sexp_processor//lib/sexp_processor.rb#43
  def auto_shift_type; end

  # Automatically shifts off the Sexp type before handing the
  # Sexp to process_<type>
  #
  # source://sexp_processor//lib/sexp_processor.rb#43
  def auto_shift_type=(_arg0); end

  # Return a stack of contexts. Most recent node is first.
  #
  # source://sexp_processor//lib/sexp_processor.rb#48
  def context; end

  # A Hash of Sexp types and Regexp.
  #
  # Print a debug message if the Sexp type matches the Hash key
  # and the Sexp's #inspect output matches the Regexp.
  #
  # source://sexp_processor//lib/sexp_processor.rb#56
  def debug; end

  # A Hash of Sexp types and Regexp.
  #
  # Print a debug message if the Sexp type matches the Hash key
  # and the Sexp's #inspect output matches the Regexp.
  #
  # source://sexp_processor//lib/sexp_processor.rb#56
  def debug=(_arg0); end

  # A default method to call if a process_<type> method is not found
  # for the Sexp type.
  #
  # source://sexp_processor//lib/sexp_processor.rb#62
  def default_method; end

  # A default method to call if a process_<type> method is not found
  # for the Sexp type.
  #
  # source://sexp_processor//lib/sexp_processor.rb#62
  def default_method=(_arg0); end

  # A scoped environment to make you happy.
  #
  # source://sexp_processor//lib/sexp_processor.rb#94
  def env; end

  # source://sexp_processor//lib/sexp_processor.rb#323
  def error_handler(type, exp = T.unsafe(nil)); end

  # Expected result class
  #
  # source://sexp_processor//lib/sexp_processor.rb#67
  def expected; end

  # Expected result class
  #
  # source://sexp_processor//lib/sexp_processor.rb#67
  def expected=(_arg0); end

  # Track a stack of contexts that the processor is in, pushing on
  # +type+ yielding, and then removing the context from the stack.
  #
  # source://sexp_processor//lib/sexp_processor.rb#385
  def in_context(type); end

  # Registers an error handler for +node+
  #
  # source://sexp_processor//lib/sexp_processor.rb#337
  def on_error_in(node_type, &block); end

  # Default Sexp processor.  Invokes process_<type> methods matching
  # the Sexp type given.  Performs additional checks as specified by
  # the initializer.
  #
  # source://sexp_processor//lib/sexp_processor.rb#217
  def process(exp); end

  # A fairly generic processor for a dummy node. Dummy nodes are used
  # when your processor is doing a complicated rewrite that replaces
  # the current sexp with multiple sexps.
  #
  # Bogus Example:
  #
  #   def process_something(exp)
  #     return s(:dummy, process(exp), s(:extra, 42))
  #   end
  #
  # source://sexp_processor//lib/sexp_processor.rb#352
  def process_dummy(exp); end

  # Raise an exception if the Sexp is not empty after processing
  #
  # source://sexp_processor//lib/sexp_processor.rb#72
  def require_empty; end

  # Raise an exception if the Sexp is not empty after processing
  #
  # source://sexp_processor//lib/sexp_processor.rb#72
  def require_empty=(_arg0); end

  # Rewrite +exp+ using rewrite_* method for +exp+'s sexp_type, if one
  # exists.
  #
  # source://sexp_processor//lib/sexp_processor.rb#179
  def rewrite(exp); end

  # Add a scope level to the current env. Eg:
  #
  #   def process_defn exp
  #     name = exp.shift
  #     args = process(exp.shift)
  #     scope do
  #       body = process(exp.shift)
  #       # ...
  #     end
  #   end
  #
  #   env[:x] = 42
  #   scope do
  #     env[:x]       # => 42
  #     env[:y] = 24
  #   end
  #   env[:y]         # => nil
  #
  # source://sexp_processor//lib/sexp_processor.rb#377
  def scope(&block); end

  # Raise an exception if no process_<type> method is found for a Sexp.
  #
  # source://sexp_processor//lib/sexp_processor.rb#77
  def strict; end

  # Raise an exception if no process_<type> method is found for a Sexp.
  #
  # source://sexp_processor//lib/sexp_processor.rb#77
  def strict=(_arg0); end

  # An array that specifies node types that are unsupported by this
  # processor. SexpProcessor will raise UnsupportedNodeError if you try
  # to process one of those node types.
  #
  # source://sexp_processor//lib/sexp_processor.rb#84
  def unsupported; end

  # An array that specifies node types that are unsupported by this
  # processor. SexpProcessor will raise UnsupportedNodeError if you try
  # to process one of those node types.
  #
  # source://sexp_processor//lib/sexp_processor.rb#84
  def unsupported=(_arg0); end

  # Emit a warning when the method in #default_method is called.
  #
  # source://sexp_processor//lib/sexp_processor.rb#89
  def warn_on_default; end

  # Emit a warning when the method in #default_method is called.
  #
  # source://sexp_processor//lib/sexp_processor.rb#89
  def warn_on_default=(_arg0); end

  class << self
    # Expand an array of directories into a flattened array of paths, eg:
    #
    #     MyProcessor.run MyProcessor.expand_dirs_to_files ARGV
    #
    # source://sexp_processor//lib/sexp_processor.rb#101
    def expand_dirs_to_files(*dirs); end

    # Cache processor methods per class.
    #
    # source://sexp_processor//lib/sexp_processor.rb#116
    def processors; end

    # Cache rewiter methods per class.
    #
    # source://sexp_processor//lib/sexp_processor.rb#123
    def rewriters; end
  end
end

# I really hate this here, but I hate subdirs in my lib dir more...
# I guess it is kinda like shaving... I'll split this out when it
# itches too much...
#
# source://sexp_processor//lib/sexp_processor.rb#399
class SexpProcessor::Environment
  # @return [Environment] a new instance of Environment
  #
  # source://sexp_processor//lib/sexp_processor.rb#400
  def initialize; end

  # Get +name+ from env at whatever scope it is defined in, or return nil.
  #
  # source://sexp_processor//lib/sexp_processor.rb#424
  def [](name); end

  # If +name+ exists in the env, set it to +val+ in whatever scope
  # it is in. If it doesn't exist, set +name+ to +val+ in the
  # current scope.
  #
  # source://sexp_processor//lib/sexp_processor.rb#434
  def []=(name, val); end

  # Flatten out all scopes and return all key/value pairs.
  #
  # source://sexp_processor//lib/sexp_processor.rb#408
  def all; end

  # Get the current/top environment.
  #
  # source://sexp_processor//lib/sexp_processor.rb#442
  def current; end

  # Return the current number of scopes.
  #
  # source://sexp_processor//lib/sexp_processor.rb#415
  def depth; end

  # Create a new scope and yield to the block passed.
  #
  # source://sexp_processor//lib/sexp_processor.rb#449
  def scope; end
end

# duh
#
# source://sexp_processor//lib/sexp_processor.rb#37
SexpProcessor::VERSION = T.let(T.unsafe(nil), String)

# SexpProcessor base exception class.
#
# source://sexp_processor//lib/sexp_processor.rb#731
class SexpProcessorError < ::StandardError; end

# Raised if assert_type encounters an unexpected sexp type.
#
# source://sexp_processor//lib/sexp_processor.rb#754
class SexpTypeError < ::SexpProcessorError; end

# Raised by SexpProcessor if it is in strict mode and sees a node for
# which there is no processor available.
#
# source://sexp_processor//lib/sexp_processor.rb#743
class UnknownNodeError < ::SexpProcessorError; end

# Raised by SexpProcessor if it sees a node type listed in its
# unsupported list.
#
# source://sexp_processor//lib/sexp_processor.rb#737
class UnsupportedNodeError < ::SexpProcessorError; end
